# Express.js

é¡åˆ¥: é–‹ç™¼æŒ‡å—
ç›¸é—œæŠ€è¡“: JavaScript, TypeScript
å»ºç«‹æ—¥æœŸ: June 17, 2025

## æ¦‚è¿°

æœ¬æ‰‹å†Šç‚ºæ‚¨æä¾›å¾é›¶é–‹å§‹æ§‹å»º Express.js TypeScript æ‡‰ç”¨ç¨‹å¼çš„å®Œæ•´æŒ‡å—ï¼Œæ¶µè“‹å¾åŸºç¤è¨­å®šåˆ°ç”Ÿç”¢ç’°å¢ƒéƒ¨ç½²çš„æ‰€æœ‰é—œéµä¸»é¡Œã€‚åŸºæ–¼2025å¹´æœ€æ–°çš„æœ€ä½³å¯¦è¸ï¼Œé©åˆåˆå­¸è€…åˆ°ä¸­ç­‰ç¨‹åº¦çš„é–‹ç™¼è€…ä½¿ç”¨ã€‚

## 1. Express.js èˆ‡ TypeScript çš„åŸºç¤ä»‹ç´¹å’Œè¨­å®š

### Express.js 5.0 æœ€æ–°ç‰¹æ€§

**Express.js 5.1.0** æ˜¯2025å¹´çš„æœ€æ–°ç‰ˆæœ¬ï¼Œå¼•å…¥äº†å¤šé …é‡è¦æ”¹é€²ï¼š [Expressjs](https://expressjs.com/2025/01/09/rewind-2024-triumphs-and-2025-vision.html)

- **Node.js 18+ è¦æ±‚**ï¼šå……åˆ†åˆ©ç”¨ç¾ä»£ JavaScript ç‰¹æ€§
- **è‡ªå‹•ç•°æ­¥éŒ¯èª¤è™•ç†**ï¼šPromise rejection è‡ªå‹•è½‰ç™¼åˆ°éŒ¯èª¤è™•ç†ä¸­é–“ä»¶ [Expressjs](https://expressjs.com/en/guide/error-handling.html)
- **è·¯ç”±åŒ¹é…å‡ç´š**ï¼šä½¿ç”¨ path-to-regexp@8.xï¼Œæé«˜å®‰å…¨æ€§
- **åŸç”Ÿ Promise æ”¯æ´**ï¼šä¸­é–“ä»¶å¯ä»¥è¿”å› rejected promises [Expressjs](https://expressjs.com/en/guide/error-handling.html)
- **ä¾è³´é …ç¾ä»£åŒ–**ï¼šæ‰€æœ‰æ ¸å¿ƒä¾è³´é …æ›´æ–°è‡³æœ€æ–°ç‰ˆæœ¬ [Expressjs +2](https://expressjs.com/2025/03/31/v5-1-latest-release.html)

### TypeScript èˆ‡ Express.js çš„å®Œç¾çµåˆ

TypeScript ç‚º Express.js å¸¶ä¾†çš„ä¸»è¦å„ªå‹¢ï¼š

- **éœæ…‹é¡å‹æª¢æŸ¥**ï¼šåœ¨ç·¨è­¯æ™‚ç™¼ç¾ç´„20%çš„ bug
- **IntelliSense æ”¯æ´**ï¼šå¼·å¤§çš„è‡ªå‹•å®Œæˆå’Œé‡æ§‹åŠŸèƒ½
- **ä»£ç¢¼å¯ç¶­è­·æ€§**ï¼šå¤§å‹å°ˆæ¡ˆä¸­çš„é¡å‹å®‰å…¨ä¿è­‰
- **åœ˜éšŠå”ä½œ**ï¼šçµ±ä¸€çš„é¡å‹è¦ç¯„æ¸›å°‘æºé€šæˆæœ¬ [GitHub +2](https://github.com/goldbergyoni/nodebestpractices)

### æ ¸å¿ƒé¡å‹å®šç¾©

```tsx
// types/express.d.ts
import { Request, Response } from 'express';

export interface User {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}

export enum UserRole {
  ADMIN = 'admin',
  USER = 'user',
  MODERATOR = 'moderator'
}

export interface AuthenticatedRequest extends Request {
  user?: User;
}

export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  error?: string;
}
```

## 2. å°ˆæ¡ˆåˆå§‹åŒ–å’Œç’°å¢ƒé…ç½®

### å¿«é€Ÿå°ˆæ¡ˆå»ºç«‹

```bash
# å»ºç«‹å°ˆæ¡ˆç›®éŒ„
mkdir express-typescript-app
cd express-typescript-app

# åˆå§‹åŒ–å°ˆæ¡ˆ
npm init -y

# å®‰è£ç”Ÿç”¢ä¾è³´
npm install express dotenv cors helmet compression morgan

# å®‰è£é–‹ç™¼ä¾è³´
npm install -D typescript ts-node nodemon @types/node @types/express @types/cors @types/morgan eslint prettier
```

### æ¨è–¦çš„å°ˆæ¡ˆçµæ§‹

```
express-typescript-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ controllers/          # æ§åˆ¶å™¨å±¤
â”‚   â”‚   â”œâ”€â”€ UserController.ts
â”‚   â”‚   â””â”€â”€ AuthController.ts
â”‚   â”œâ”€â”€ routes/              # è·¯ç”±å®šç¾©
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ userRoutes.ts
â”‚   â”‚   â””â”€â”€ authRoutes.ts
â”‚   â”œâ”€â”€ middleware/          # ä¸­é–“ä»¶
â”‚   â”‚   â”œâ”€â”€ auth.ts
â”‚   â”‚   â”œâ”€â”€ errorHandler.ts
â”‚   â”‚   â””â”€â”€ validation.ts
â”‚   â”œâ”€â”€ models/             # è³‡æ–™æ¨¡å‹
â”‚   â”‚   â””â”€â”€ User.ts
â”‚   â”œâ”€â”€ services/           # æ¥­å‹™é‚è¼¯å±¤
â”‚   â”‚   â””â”€â”€ UserService.ts
â”‚   â”œâ”€â”€ utils/              # å·¥å…·å‡½æ•¸
â”‚   â”‚   â”œâ”€â”€ logger.ts
â”‚   â”‚   â””â”€â”€ validator.ts
â”‚   â”œâ”€â”€ types/              # é¡å‹å®šç¾©
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â””â”€â”€ express.d.ts
â”‚   â”œâ”€â”€ config/             # é…ç½®æ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ database.ts
â”‚   â”‚   â””â”€â”€ environment.ts
â”‚   â”œâ”€â”€ app.ts              # æ‡‰ç”¨ç¨‹å¼ä¸»æ–‡ä»¶
â”‚   â””â”€â”€ index.ts            # å…¥å£æ–‡ä»¶
â”œâ”€â”€ tests/                  # æ¸¬è©¦æ–‡ä»¶
â”œâ”€â”€ dist/                   # ç·¨è­¯è¼¸å‡º
â”œâ”€â”€ .env                    # ç’°å¢ƒè®Šæ•¸
â”œâ”€â”€ .env.example           # ç’°å¢ƒè®Šæ•¸ç¯„ä¾‹
â”œâ”€â”€ tsconfig.json          # TypeScript é…ç½®
â”œâ”€â”€ nodemon.json           # Nodemon é…ç½®
â””â”€â”€ package.json
```

### TypeScript é…ç½® (tsconfig.json)

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "incremental": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "types": ["node"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
}
```

### ç’°å¢ƒè®Šæ•¸é…ç½®

```bash
# .env
NODE_ENV=development
PORT=3000
LOG_LEVEL=debug

# Database
DATABASE_URL=mongodb://localhost:27017/myapp
# æˆ–è€… PostgreSQL# DATABASE_URL=postgresql://username:password@localhost:5432/myapp# JWT
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=7d

# CORS
CORS_ORIGIN=http://localhost:3000

# Redis (ç”¨æ–¼å¿«å–)
REDIS_HOST=localhost
REDIS_PORT=6379
```

### Package.json è…³æœ¬é…ç½®

```json
{
  "scripts": {
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "format": "prettier --write src/**/*.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "clean": "rm -rf dist"
  }
}
```

## 3. è·¯ç”±è¨­è¨ˆå’Œä¸­ä»‹è»Ÿé«” (Middleware)

### Express Router é€²éšä½¿ç”¨

```tsx
// routes/userRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import { body, validationResult } from 'express-validator';
import { UserController } from '../controllers/UserController';
import { authenticateToken } from '../middleware/auth';

const router = Router();
const userController = new UserController();

// è·¯ç”±ç‰¹å®šä¸­é–“ä»¶
const timeLog = (req: Request, res: Response, next: NextFunction) => {
  console.log('Time: ', Date.now());
  next();
};

router.use(timeLog);

// é©—è­‰ä¸­é–“ä»¶
const userValidation = [
  body('email').isEmail().withMessage('æœ‰æ•ˆçš„é›»å­éƒµä»¶åœ°å€å¿…é ˆ'),
  body('name').notEmpty().withMessage('å§“åæ˜¯å¿…éœ€çš„'),
  body('age').isInt({ min: 0 }).withMessage('å¹´é½¡å¿…é ˆæ˜¯æ­£æ•´æ•¸')
];

// è·¯ç”±å®šç¾©
router.get('/', userController.getAllUsers);
router.post('/', userValidation, userController.createUser);
router.get('/:id', userController.getUserById);
router.put('/:id', authenticateToken, userValidation, userController.updateUser);
router.delete('/:id', authenticateToken, userController.deleteUser);

export default router;
```

### è‡ªè¨‚ä¸­é–“ä»¶é–‹ç™¼

```tsx
// middleware/custom.ts
import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';

// è«‹æ±‚ ID ä¸­é–“ä»¶
export const requestId = (req: Request, res: Response, next: NextFunction): void => {
  req.requestId = uuidv4();
  res.setHeader('X-Request-ID', req.requestId);
  next();
};

// éŸ¿æ‡‰æ™‚é–“ä¸­é–“ä»¶
export const responseTime = (req: Request, res: Response, next: NextFunction): void => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - start;
    res.setHeader('X-Response-Time', `${duration}ms`);
    console.log(`${req.method} ${req.path} - ${duration}ms`);
  });

  next();
};

// è«‹æ±‚é™æµä¸­é–“ä»¶
interface RateLimitOptions {
  windowMs: number;
  max: number;
  message: string;
}

export const createRateLimit = (options: RateLimitOptions) => {
  const requests = new Map<string, { count: number; resetTime: number }>();

  return (req: Request, res: Response, next: NextFunction): void => {
    const key = req.ip;
    const now = Date.now();

    if (!requests.has(key)) {
      requests.set(key, { count: 1, resetTime: now + options.windowMs });
      next();
      return;
    }

    const userRequests = requests.get(key)!;

    if (now > userRequests.resetTime) {
      userRequests.count = 1;
      userRequests.resetTime = now + options.windowMs;
      next();
      return;
    }

    if (userRequests.count >= options.max) {
      res.status(429).json({
        success: false,
        message: options.message
      });
      return;
    }

    userRequests.count++;
    next();
  };
};
```

## 4. è³‡æ–™åº«æ•´åˆ

### MongoDB èˆ‡ Mongoose æ•´åˆ

```tsx
// config/database.ts
import mongoose from 'mongoose';

export const connectMongoDB = async (): Promise<void> => {
  try {
    const connectionString = process.env.MONGODB_URI!;

    await mongoose.connect(connectionString, {
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
      bufferCommands: false,
      bufferMaxEntries: 0,
    });

    console.log('MongoDB é€£æ¥æˆåŠŸ');
  } catch (error) {
    console.error('MongoDB é€£æ¥å¤±æ•—:', error);
    process.exit(1);
  }
};

// models/User.ts
import { Schema, model, Document } from 'mongoose';

interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  role: 'user' | 'admin' | 'moderator';
  profile: {
    avatar?: string;
    bio?: string;
    socialLinks?: Record<string, string>;
  };
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>({
  name: {
    type: String,
    required: [true, 'å§“åæ˜¯å¿…éœ€çš„'],
    trim: true,
    maxlength: [50, 'å§“åä¸èƒ½è¶…é50å€‹å­—ç¬¦']
  },
  email: {
    type: String,
    required: [true, 'é›»å­éƒµä»¶æ˜¯å¿…éœ€çš„'],
    unique: true,
    lowercase: true,
    validate: {
      validator: (email: string) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
      message: 'ç„¡æ•ˆçš„é›»å­éƒµä»¶æ ¼å¼'
    }
  },
  password: {
    type: String,
    required: [true, 'å¯†ç¢¼æ˜¯å¿…éœ€çš„'],
    minlength: [8, 'å¯†ç¢¼è‡³å°‘éœ€è¦8å€‹å­—ç¬¦'],
    select: false
  },
  role: {
    type: String,
    enum: ['user', 'admin', 'moderator'],
    default: 'user'
  },
  profile: {
    avatar: String,
    bio: {
      type: String,
      maxlength: [500, 'å€‹äººç°¡ä»‹ä¸èƒ½è¶…é500å€‹å­—ç¬¦']
    },
    socialLinks: {
      type: Map,
      of: String
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// ç´¢å¼•
userSchema.index({ email: 1 });
userSchema.index({ createdAt: -1 });

export const User = model<IUser>('User', userSchema);
```

### PostgreSQL èˆ‡ Prisma æ•´åˆ

```
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  role      Role     @default(USER)
  posts     Post[]
  profile   Profile?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  avatar String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("posts")
}

enum Role {
  USER
  ADMIN
  MODERATOR
}
```

```tsx
// services/prisma.service.ts
import { PrismaClient, Prisma } from '@prisma/client';

export class DatabaseService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient({
      log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['error'],
      errorFormat: 'pretty',
    });
  }

  async connect(): Promise<void> {
    await this.prisma.$connect();
    console.log('Prisma é€£æ¥æˆåŠŸ');
  }

  async disconnect(): Promise<void> {
    await this.prisma.$disconnect();
  }

  get client(): PrismaClient {
    return this.prisma;
  }

  async transaction<T>(fn: (prisma: PrismaClient) => Promise<T>): Promise<T> {
    return await this.prisma.$transaction(fn);
  }
}
```

## 5. èº«ä»½é©—è­‰å’Œæˆæ¬Š

### JWT èº«ä»½é©—è­‰å¯¦ä½œ

```tsx
// services/auth.service.ts
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { User, JWTPayload } from '../types/auth.types';

export class AuthService {
  async generateTokens(user: User): Promise<{ accessToken: string; refreshToken: string }> {
    const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
      sub: user.id,
      email: user.email,
      role: user.role
    };

    const accessToken = jwt.sign(payload, process.env.JWT_SECRET!, {
      expiresIn: '15m',
      algorithm: 'HS256'
    });

    const refreshToken = jwt.sign(payload, process.env.JWT_REFRESH_SECRET!, {
      expiresIn: '7d',
      algorithm: 'HS256'
    });

    return { accessToken, refreshToken };
  }

  async hashPassword(password: string): Promise<string> {
    const saltRounds = 12;
    return bcrypt.hash(password, saltRounds);
  }

  async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }
}

// middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { JWTPayload, User } from '../types/auth.types';
import { AppError } from '../utils/errors';

export interface AuthenticatedRequest extends Request {
  user?: User;
}

export const authenticateToken = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader?.split(' ')[1];

    if (!token) {
      throw new AppError('Access token required', 401);
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;

// å¾è³‡æ–™åº«ç²å–ç”¨æˆ¶è³‡è¨Š
    const user = await getUserById(decoded.sub);
    if (!user) {
      throw new AppError('User not found', 401);
    }

    req.user = user;
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new AppError('Invalid token', 401));
    } else {
      next(error);
    }
  }
};
```

### åŸºæ–¼è§’è‰²çš„å­˜å–æ§åˆ¶ (RBAC)

```tsx
// middleware/rbac.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { UserRole } from '../types/auth.types';
import { AuthenticatedRequest } from './auth.middleware';
import { AppError } from '../utils/errors';

export const requireRole = (roles: UserRole[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    if (!req.user) {
      throw new AppError('Authentication required', 401);
    }

    if (!roles.includes(req.user.role)) {
      throw new AppError('Insufficient permissions', 403);
    }

    next();
  };
};

// ä½¿ç”¨ç¯„ä¾‹
app.get('/admin/users',
  authenticateToken,
  requireRole([UserRole.ADMIN]),
  getUsersController
);
```

## 6. éŒ¯èª¤è™•ç†å’Œæ—¥èªŒè¨˜éŒ„

### è‡ªè¨‚éŒ¯èª¤é¡åˆ¥

```tsx
// utils/errors.ts
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly timestamp: Date;

  constructor(
    message: string,
    statusCode: number = 500,
    isOperational: boolean = true
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date();

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  public readonly fields: Record<string, string>;

  constructor(message: string, fields: Record<string, string>) {
    super(message, 400);
    this.fields = fields;
  }
}
```

### å…¨åŸŸéŒ¯èª¤è™•ç†ä¸­é–“ä»¶

```tsx
// middleware/error.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors';
import { logger } from '../utils/logger';

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  let err = error as AppError;

// è¨˜éŒ„éŒ¯èª¤
  logger.error('Error occurred:', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

// è™•ç†å·²çŸ¥éŒ¯èª¤
  if (!(error instanceof AppError)) {
    err = new AppError('Internal server error', 500, false);
  }

// é–‹ç™¼ç’°å¢ƒé¡¯ç¤ºè©³ç´°éŒ¯èª¤
  if (process.env.NODE_ENV === 'development') {
    res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.message,
        stack: err.stack,
        statusCode: err.statusCode
      }
    });
  } else {
// ç”Ÿç”¢ç’°å¢ƒéš±è—æ•æ„Ÿè³‡è¨Š
    res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.isOperational ? err.message : 'Something went wrong',
        statusCode: err.statusCode
      }
    });
  }
};
```

### æ—¥èªŒè¨˜éŒ„æœ€ä½³å¯¦è¸

```tsx
// utils/logger.ts (ä½¿ç”¨Winston)
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';

const logFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  defaultMeta: {
    service: 'express-api',
    environment: process.env.NODE_ENV
  },
  transports: [
    new DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      level: 'error',
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d'
    }),
    new DailyRotateFile({
      filename: 'logs/combined-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d'
    })
  ]
});

// é–‹ç™¼ç’°å¢ƒæ·»åŠ æ§åˆ¶å°è¼¸å‡º
if (process.env.NODE_ENV === 'development') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}
```

## 7. æ¸¬è©¦ç­–ç•¥

### Jest å–®å…ƒæ¸¬è©¦é…ç½®

```jsx
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "testEnvironment": "node",
    "collectCoverageFrom": [
      "src/**/*.ts",
      "!src/index.ts"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

### API ç«¯é»æ¸¬è©¦

```tsx
// tests/integration/api.test.ts
import request from 'supertest';
import app from '../../src/app';

describe('API Integration Tests', () => {
  describe('GET /api/users', () => {
    it('æ‡‰è©²è¿”å›ç”¨æˆ¶åˆ—è¡¨', async () => {
      const response = await request(app)
        .get('/api/users')
        .expect('Content-Type', /json/)
        .expect(200);

      expect(response.body).toHaveProperty('users');
      expect(Array.isArray(response.body.users)).toBe(true);
    });
  });

  describe('POST /api/users', () => {
    it('æ‡‰è©²å‰µå»ºæ–°ç”¨æˆ¶', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect('Content-Type', /json/)
        .expect(201);

      expect(response.body).toHaveProperty('user');
      expect(response.body.user.name).toBe(userData.name);
    });
  });
});
```

### æ¸¬è©¦è³‡æ–™åº«è¨­å®š

```tsx
// tests/setup/database.ts
import mongoose from 'mongoose';
import { MongoMemoryServer } from 'mongodb-memory-server';

let mongoServer: MongoMemoryServer;

beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  const mongoUri = mongoServer.getUri();
  await mongoose.connect(mongoUri);
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

beforeEach(async () => {
  const collections = mongoose.connection.collections;
  for (const key in collections) {
    await collections[key].deleteMany({});
  }
});
```

## 8. éƒ¨ç½²å’Œç”Ÿç”¢ç’°å¢ƒé…ç½®

### Docker å®¹å™¨åŒ–

```docker
# Dockerfile (ç”Ÿç”¢ç’°å¢ƒ)
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

FROM node:18-alpine as production

ENV NODE_ENV=production
ENV PORT=3000

# å»ºç«‹é root ç”¨æˆ¶
RUN addgroup -g 1001 -S nodejs
RUN adduser -S express -u 1001

WORKDIR /app

# è¤‡è£½ä¾è³´é …
COPY --from=builder --chown=express:nodejs /app/node_modules ./node_modules
COPY --chown=express:nodejs . .

USER express

EXPOSE 3000

# å¥åº·æª¢æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["node", "dist/index.js"]
```

### Docker Compose é…ç½®

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DB_HOST=db
      - DB_PORT=5432
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - db
      - redis
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:

```

### CI/CD GitHub Actions

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test
      env:
        NODE_ENV: test
        DB_HOST: localhost
        DB_PORT: 5432

    - name: Run coverage
      run: npm run test:coverage

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy to production
      run: echo "éƒ¨ç½²åˆ°ç”Ÿç”¢ç’°å¢ƒ"
```

## 9. å®‰å…¨æ€§æœ€ä½³å¯¦è¸

### å®‰å…¨æ¨™é ­é…ç½®

```tsx
// config/security.config.ts
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import cors from 'cors';

export const helmetConfig = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'"],
      connectSrc: ["'self'", "https://api.example.com"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
});

export const corsConfig = {
  origin: process.env.NODE_ENV === 'production'
    ? ['https://yourdomain.com']
    : ['http://localhost:3000'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allow edHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
  credentials: true
};

export const rateLimitConfig = rateLimit({
  windowMs: 15 *  60 * 1000,// 15åˆ†é˜
  max: 100,// æ¯IPé™åˆ¶100æ¬¡è«‹æ±‚
  message: {
    error: 'è«‹æ±‚å¤ªé »ç¹ï¼Œè«‹ç¨å¾Œå†è©¦'
  },
  standardHeaders: true,
  legacyHeaders: false
});

```

### è³‡æ–™é©—è­‰å’Œæ¸…ç†

```tsx
// middleware/validation.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { ValidationError } from '../utils/errors';

export const validateBody = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fields = error.errors.reduce((acc, err) => {
          acc[err.path.join('.')] = err.message;
          return acc;
        }, {} as Record<string, string>);

        next(new ValidationError('Validation failed', fields));
      } else {
        next(error);
      }
    }
  };
};

// schemas/user.schema.ts
import { z } from 'zod';

export const createUserSchema = z.object({
  username: z.string()
    .min(3, 'ç”¨æˆ¶åè‡³å°‘éœ€è¦3å€‹å­—ç¬¦')
    .max(30, 'ç”¨æˆ¶åä¸èƒ½è¶…é30å€‹å­—ç¬¦')
    .regex(/^[a-zA-Z0-9_]+$/, 'ç”¨æˆ¶ååªèƒ½åŒ…å«å­—æ¯ã€æ•¸å­—å’Œä¸‹åŠƒç·š'),
  email: z.string().email('ç„¡æ•ˆçš„é›»å­éƒµä»¶æ ¼å¼'),
  password: z.string()
    .min(8, 'å¯†ç¢¼è‡³å°‘éœ€è¦8å€‹å­—ç¬¦')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
           'å¯†ç¢¼å¿…é ˆåŒ…å«å¤§å°å¯«å­—æ¯ã€æ•¸å­—å’Œç‰¹æ®Šå­—ç¬¦')
});

```

## 10. æ•ˆèƒ½å„ªåŒ–

### Redis å¿«å–æ©Ÿåˆ¶

```tsx
// services/cache.service.ts
import Redis from 'ioredis';

class CacheService {
  private redis: Redis;

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD
    });
  }

  cache(options: { ttl?: number; keyGenerator?: (req: Request) => string } = {}) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const cacheKey = options.keyGenerator?.(req) || this.defaultKeyGenerator(req);

      const cached = await this.redis.get(cacheKey);
      if (cached) {
        const data = JSON.parse(cached);
        res.set('X-Cache', 'HIT');
        return res.status(data.statusCode).json(data.body);
      }

      const originalJson = res.json.bind(res);
      res.json = (obj: any) => {
        this.cacheResponse(cacheKey, res.statusCode, obj, options.ttl || 300);
        res.set('X-Cache', 'MISS');
        return originalJson(obj);
      };

      next();
    };
  }

  private async cacheResponse(key: string, statusCode: number, body: any, ttl: number) {
    await this.redis.setex(key, ttl, JSON.stringify({ statusCode, body }));
  }

  private defaultKeyGenerator(req: Request): string {
    return `${req.method}:${req.originalUrl}`;
  }
}

export const cacheService = new CacheService();
```

### å£“ç¸®å’Œéœæ…‹æª”æ¡ˆå„ªåŒ–

```tsx
// middleware/compression.middleware.ts
import compression from 'compression';

export const smartCompression = compression({
  level: (req, res) => {
    const isMobile = /Mobile|Android|iPhone/i.test(req.get('User-Agent') || '');
    return isMobile ? 6 : 9;
  },
  filter: (req, res) => {
    const contentType = res.get('Content-Type') || '';
    return contentType.includes('json') || contentType.startsWith('text/');
  }
});
```

## 11. å¯¦éš›ç¯„ä¾‹ç¨‹å¼ç¢¼å’Œå®Œæ•´å°ˆæ¡ˆç¤ºä¾‹

### å®Œæ•´çš„ CRUD API æ§åˆ¶å™¨

```tsx
// controllers/UserController.ts
import { Request, Response, NextFunction } from 'express';
import { UserService } from '../services/UserService';
import { AppError } from '../utils/errors';

export class UserController {
  constructor(private userService: UserService) {}

  async createUser(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const userData = req.body;
      const newUser = await this.userService.create(userData);

      res.status(201).json({
        success: true,
        data: newUser,
        message: 'ç”¨æˆ¶å‰µå»ºæˆåŠŸ'
      });
    } catch (error) {
      next(error);
    }
  }

  async getAllUsers(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = Math.min(parseInt(req.query.limit as string) || 10, 100);

      const result = await this.userService.findAll({ page, limit });

      res.json({
        success: true,
        data: result.users,
        pagination: {
          total: result.total,
          page,
          limit,
          hasMore: result.hasMore
        }
      });
    } catch (error) {
      next(error);
    }
  }

  async getUserById(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { id } = req.params;
      const user = await this.userService.findById(id);

      if (!user) {
        throw new AppError('ç”¨æˆ¶æœªæ‰¾åˆ°', 404);
      }

      res.json({
        success: true,
        data: user
      });
    } catch (error) {
      next(error);
    }
  }

  async updateUser(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const updatedUser = await this.userService.update(id, updateData);

      res.json({
        success: true,
        data: updatedUser,
        message: 'ç”¨æˆ¶æ›´æ–°æˆåŠŸ'
      });
    } catch (error) {
      next(error);
    }
  }

  async deleteUser(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { id } = req.params;
      await this.userService.delete(id);

      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}
```

### æª”æ¡ˆä¸Šå‚³è™•ç†æœå‹™

```tsx
// services/FileUploadService.ts
import multer from 'multer';
import sharp from 'sharp';
import path from 'path';
import fs from 'fs';

export class FileUploadService {
  private storage = multer.diskStorage({
    destination: (req, file, cb) => {
      const dateFolder = new Date().toISOString().split('T')[0];
      const destPath = path.join(__dirname, '../uploads', dateFolder);
      fs.mkdirSync(destPath, { recursive: true });
      cb(null, destPath);
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`);
    }
  });

  private fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('ç„¡æ•ˆçš„æª”æ¡ˆé¡å‹'));
    }
  };

  getUploadMiddleware() {
    return multer({
      storage: this.storage,
      limits: { fileSize: 10 * 1024 * 1024 },// 10MB
      fileFilter: this.fileFilter
    });
  }

  async processImage(filePath: string): Promise<string> {
    const processedPath = filePath.replace(/(\.[^.]+)$/, '_processed$1');

    await sharp(filePath)
      .resize(1200, 1200, { fit: 'inside', withoutEnlargement: true })
      .jpeg({ quality: 85, progressive: true })
      .toFile(processedPath);

    return processedPath;
  }
}
```

### å®Œæ•´çš„æ‡‰ç”¨ç¨‹å¼é…ç½®

```tsx
// app.ts
import express from 'express';
import cors from 'cors';
import { helmetConfig, corsConfig, rateLimitConfig } from './config/security.config';
import { errorHandler } from './middleware/error.middleware';
import { logger } from './utils/logger';
import { requestId, responseTime } from './middleware/custom';
import { smartCompression } from './middleware/compression.middleware';
import userRoutes from './routes/userRoutes';
import authRoutes from './routes/authRoutes';

class App {
  public app: express.Application;

  constructor() {
    this.app = express();
    this.initializeMiddleware();
    this.initializeRoutes();
    this.initializeErrorHandling();
  }

  private initializeMiddleware(): void {
// ä¿¡ä»»ä»£ç†ï¼ˆç”¨æ–¼ç”Ÿç”¢ç’°å¢ƒï¼‰
    if (process.env.NODE_ENV === 'production') {
      this.app.set('trust proxy', 1);
    }

// å®‰å…¨ä¸­é–“ä»¶
    this.app.use(helmetConfig);
    this.app.use(cors(corsConfig));
    this.app.use(rateLimitConfig);
    this.app.use(smartCompression);

// è«‹æ±‚è§£æå’Œè™•ç†
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// è‡ªè¨‚ä¸­é–“ä»¶
    this.app.use(requestId);
    this.app.use(responseTime);

// è«‹æ±‚æ—¥èªŒ
    this.app.use((req, res, next) => {
      logger.info('Incoming request', {
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent')
      });
      next();
    });
  }

  private initializeRoutes(): void {
// å¥åº·æª¢æŸ¥
    this.app.get('/health', (req, res) => {
      res.status(200).json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
      });
    });

// API è·¯ç”±
    this.app.use('/api/v1/auth', authRoutes);
    this.app.use('/api/v1/users', userRoutes);
  }

  private initializeErrorHandling(): void {
// 404 è™•ç†
    this.app.use((req, res) => {
      res.status(404).json({
        success: false,
        message: `æ‰¾ä¸åˆ°è·¯ç”± ${req.originalUrl}`
      });
    });

// å…¨åŸŸéŒ¯èª¤è™•ç†
    this.app.use(errorHandler);
  }
}

export default new App().app;
```

### ä¼ºæœå™¨å•Ÿå‹•æª”æ¡ˆ

```tsx
// index.ts
import app from './app';
import { connectMongoDB } from './config/database';
import { logger } from './utils/logger';

const PORT = process.env.PORT || 3000;

async function startServer() {
  try {
// é€£æ¥è³‡æ–™åº«
    await connectMongoDB();

// å•Ÿå‹•ä¼ºæœå™¨
    const server = app.listen(PORT, () => {
      logger.info(`ğŸš€ Server is running on port ${PORT}`);
      logger.info(`ğŸ“¡ Environment: ${process.env.NODE_ENV}`);
      logger.info(`ğŸ”— Local: http://localhost:${PORT}`);
    });

// å„ªé›…é—œé–‰è™•ç†
    const gracefulShutdown = (signal: string) => {
      logger.info(`${signal} received`);
      server.close(() => {
        logger.info('Server closed');
        process.exit(0);
      });
    };

    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));

  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

startServer();
```

## ç¸½çµ

é€™ä»½å®Œæ•´çš„ Express.js TypeScript æ‰‹å†Šæ¶µè“‹äº†ç¾ä»£ Web é–‹ç™¼çš„æ‰€æœ‰é‡è¦é¢å‘ï¼š

### é—œéµç‰¹è‰²

- **2025å¹´æœ€æ–°æŠ€è¡“**ï¼šExpress 5.0ã€TypeScript 5.xã€æœ€æ–°å®‰å…¨å¯¦è¸
- **å®Œæ•´ç¨‹å¼ç¢¼ç¯„ä¾‹**ï¼šå¯ç›´æ¥ä½¿ç”¨çš„å¯¦éš›ä»£ç¢¼
- **ç”Ÿç”¢ç’°å¢ƒå°±ç·’**ï¼šåŒ…å«éƒ¨ç½²ã€ç›£æ§ã€å„ªåŒ–ç­–ç•¥
- **å®‰å…¨å„ªå…ˆ**ï¼šéµå¾ª OWASP å®‰å…¨æ¨™æº–
- **æ•ˆèƒ½å„ªåŒ–**ï¼šå¿«å–ã€å£“ç¸®ã€è³‡æ–™åº«å„ªåŒ–
- **æ¸¬è©¦å°å‘**ï¼šå®Œæ•´çš„æ¸¬è©¦ç­–ç•¥å’Œç¯„ä¾‹

### é–‹ç™¼å·¥ä½œæµç¨‹

1. **è¨­å®šé–‹ç™¼ç’°å¢ƒ**ï¼šTypeScript + Express + é–‹ç™¼å·¥å…·
2. **å»ºç«‹åŸºç¤æ¶æ§‹**ï¼šè·¯ç”±ã€ä¸­é–“ä»¶ã€è³‡æ–™åº«
3. **å¯¦ä½œæ¥­å‹™é‚è¼¯**ï¼šæ§åˆ¶å™¨ã€æœå‹™å±¤ã€é©—è­‰
4. **æ–°å¢å®‰å…¨æ€§**ï¼šèªè­‰ã€æˆæ¬Šã€è³‡æ–™é©—è­‰
5. **æ•ˆèƒ½å„ªåŒ–**ï¼šå¿«å–ã€å£“ç¸®ã€ç›£æ§
6. **æ¸¬è©¦å’Œéƒ¨ç½²**ï¼šå–®å…ƒæ¸¬è©¦ã€CI/CDã€å®¹å™¨åŒ–

### æœ€ä½³å¯¦è¸è¦é»

- ä½¿ç”¨ TypeScript ç²å¾—é¡å‹å®‰å…¨
- å¯¦ä½œé©ç•¶çš„éŒ¯èª¤è™•ç†å’Œæ—¥èªŒè¨˜éŒ„
- éµå¾ª RESTful API è¨­è¨ˆåŸå‰‡
- å¯¦æ–½å¼·å¤§çš„å®‰å…¨æªæ–½
- é€²è¡Œå……åˆ†çš„æ¸¬è©¦è¦†è“‹
- å„ªåŒ–æ‡‰ç”¨ç¨‹å¼æ•ˆèƒ½
- ä½¿ç”¨ç¾ä»£åŒ–éƒ¨ç½²ç­–ç•¥

é€™ä»½æ‰‹å†Šå°‡å”åŠ©æ‚¨å»ºæ§‹é«˜å“è³ªã€å¯ç¶­è­·ã€å®‰å…¨çš„ Express.js TypeScript æ‡‰ç”¨ç¨‹å¼ï¼Œæ»¿è¶³ç¾ä»£ Web é–‹ç™¼çš„å„ç¨®éœ€æ±‚ã€‚