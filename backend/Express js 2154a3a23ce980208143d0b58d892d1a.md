# Express.js

類別: 開發指南
相關技術: JavaScript, TypeScript
建立日期: June 17, 2025

## 概述

本手冊為您提供從零開始構建 Express.js TypeScript 應用程式的完整指南，涵蓋從基礎設定到生產環境部署的所有關鍵主題。基於2025年最新的最佳實踐，適合初學者到中等程度的開發者使用。

## 1. Express.js 與 TypeScript 的基礎介紹和設定

### Express.js 5.0 最新特性

**Express.js 5.1.0** 是2025年的最新版本，引入了多項重要改進： [Expressjs](https://expressjs.com/2025/01/09/rewind-2024-triumphs-and-2025-vision.html)

- **Node.js 18+ 要求**：充分利用現代 JavaScript 特性
- **自動異步錯誤處理**：Promise rejection 自動轉發到錯誤處理中間件 [Expressjs](https://expressjs.com/en/guide/error-handling.html)
- **路由匹配升級**：使用 path-to-regexp@8.x，提高安全性
- **原生 Promise 支援**：中間件可以返回 rejected promises [Expressjs](https://expressjs.com/en/guide/error-handling.html)
- **依賴項現代化**：所有核心依賴項更新至最新版本 [Expressjs +2](https://expressjs.com/2025/03/31/v5-1-latest-release.html)

### TypeScript 與 Express.js 的完美結合

TypeScript 為 Express.js 帶來的主要優勢：

- **靜態類型檢查**：在編譯時發現約20%的 bug
- **IntelliSense 支援**：強大的自動完成和重構功能
- **代碼可維護性**：大型專案中的類型安全保證
- **團隊協作**：統一的類型規範減少溝通成本 [GitHub +2](https://github.com/goldbergyoni/nodebestpractices)

### 核心類型定義

```tsx
// types/express.d.ts
import { Request, Response } from 'express';

export interface User {
  id: string;
  email: string;
  username: string;
  role: UserRole;
  createdAt: Date;
  updatedAt: Date;
}

export enum UserRole {
  ADMIN = 'admin',
  USER = 'user',
  MODERATOR = 'moderator'
}

export interface AuthenticatedRequest extends Request {
  user?: User;
}

export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  error?: string;
}
```

## 2. 專案初始化和環境配置

### 快速專案建立

```bash
# 建立專案目錄
mkdir express-typescript-app
cd express-typescript-app

# 初始化專案
npm init -y

# 安裝生產依賴
npm install express dotenv cors helmet compression morgan

# 安裝開發依賴
npm install -D typescript ts-node nodemon @types/node @types/express @types/cors @types/morgan eslint prettier
```

### 推薦的專案結構

```
express-typescript-app/
├── src/
│   ├── controllers/          # 控制器層
│   │   ├── UserController.ts
│   │   └── AuthController.ts
│   ├── routes/              # 路由定義
│   │   ├── index.ts
│   │   ├── userRoutes.ts
│   │   └── authRoutes.ts
│   ├── middleware/          # 中間件
│   │   ├── auth.ts
│   │   ├── errorHandler.ts
│   │   └── validation.ts
│   ├── models/             # 資料模型
│   │   └── User.ts
│   ├── services/           # 業務邏輯層
│   │   └── UserService.ts
│   ├── utils/              # 工具函數
│   │   ├── logger.ts
│   │   └── validator.ts
│   ├── types/              # 類型定義
│   │   ├── index.ts
│   │   └── express.d.ts
│   ├── config/             # 配置文件
│   │   ├── database.ts
│   │   └── environment.ts
│   ├── app.ts              # 應用程式主文件
│   └── index.ts            # 入口文件
├── tests/                  # 測試文件
├── dist/                   # 編譯輸出
├── .env                    # 環境變數
├── .env.example           # 環境變數範例
├── tsconfig.json          # TypeScript 配置
├── nodemon.json           # Nodemon 配置
└── package.json
```

### TypeScript 配置 (tsconfig.json)

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "moduleResolution": "Node",
    "lib": ["ES2022"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "incremental": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "types": ["node"]
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
}
```

### 環境變數配置

```bash
# .env
NODE_ENV=development
PORT=3000
LOG_LEVEL=debug

# Database
DATABASE_URL=mongodb://localhost:27017/myapp
# 或者 PostgreSQL# DATABASE_URL=postgresql://username:password@localhost:5432/myapp# JWT
JWT_SECRET=your-super-secret-jwt-key
JWT_EXPIRES_IN=7d

# CORS
CORS_ORIGIN=http://localhost:3000

# Redis (用於快取)
REDIS_HOST=localhost
REDIS_PORT=6379
```

### Package.json 腳本配置

```json
{
  "scripts": {
    "dev": "nodemon src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "format": "prettier --write src/**/*.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "clean": "rm -rf dist"
  }
}
```

## 3. 路由設計和中介軟體 (Middleware)

### Express Router 進階使用

```tsx
// routes/userRoutes.ts
import { Router, Request, Response, NextFunction } from 'express';
import { body, validationResult } from 'express-validator';
import { UserController } from '../controllers/UserController';
import { authenticateToken } from '../middleware/auth';

const router = Router();
const userController = new UserController();

// 路由特定中間件
const timeLog = (req: Request, res: Response, next: NextFunction) => {
  console.log('Time: ', Date.now());
  next();
};

router.use(timeLog);

// 驗證中間件
const userValidation = [
  body('email').isEmail().withMessage('有效的電子郵件地址必須'),
  body('name').notEmpty().withMessage('姓名是必需的'),
  body('age').isInt({ min: 0 }).withMessage('年齡必須是正整數')
];

// 路由定義
router.get('/', userController.getAllUsers);
router.post('/', userValidation, userController.createUser);
router.get('/:id', userController.getUserById);
router.put('/:id', authenticateToken, userValidation, userController.updateUser);
router.delete('/:id', authenticateToken, userController.deleteUser);

export default router;
```

### 自訂中間件開發

```tsx
// middleware/custom.ts
import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';

// 請求 ID 中間件
export const requestId = (req: Request, res: Response, next: NextFunction): void => {
  req.requestId = uuidv4();
  res.setHeader('X-Request-ID', req.requestId);
  next();
};

// 響應時間中間件
export const responseTime = (req: Request, res: Response, next: NextFunction): void => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = Date.now() - start;
    res.setHeader('X-Response-Time', `${duration}ms`);
    console.log(`${req.method} ${req.path} - ${duration}ms`);
  });

  next();
};

// 請求限流中間件
interface RateLimitOptions {
  windowMs: number;
  max: number;
  message: string;
}

export const createRateLimit = (options: RateLimitOptions) => {
  const requests = new Map<string, { count: number; resetTime: number }>();

  return (req: Request, res: Response, next: NextFunction): void => {
    const key = req.ip;
    const now = Date.now();

    if (!requests.has(key)) {
      requests.set(key, { count: 1, resetTime: now + options.windowMs });
      next();
      return;
    }

    const userRequests = requests.get(key)!;

    if (now > userRequests.resetTime) {
      userRequests.count = 1;
      userRequests.resetTime = now + options.windowMs;
      next();
      return;
    }

    if (userRequests.count >= options.max) {
      res.status(429).json({
        success: false,
        message: options.message
      });
      return;
    }

    userRequests.count++;
    next();
  };
};
```

## 4. 資料庫整合

### MongoDB 與 Mongoose 整合

```tsx
// config/database.ts
import mongoose from 'mongoose';

export const connectMongoDB = async (): Promise<void> => {
  try {
    const connectionString = process.env.MONGODB_URI!;

    await mongoose.connect(connectionString, {
      maxPoolSize: 10,
      serverSelectionTimeoutMS: 5000,
      socketTimeoutMS: 45000,
      bufferCommands: false,
      bufferMaxEntries: 0,
    });

    console.log('MongoDB 連接成功');
  } catch (error) {
    console.error('MongoDB 連接失敗:', error);
    process.exit(1);
  }
};

// models/User.ts
import { Schema, model, Document } from 'mongoose';

interface IUser extends Document {
  name: string;
  email: string;
  password: string;
  role: 'user' | 'admin' | 'moderator';
  profile: {
    avatar?: string;
    bio?: string;
    socialLinks?: Record<string, string>;
  };
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>({
  name: {
    type: String,
    required: [true, '姓名是必需的'],
    trim: true,
    maxlength: [50, '姓名不能超過50個字符']
  },
  email: {
    type: String,
    required: [true, '電子郵件是必需的'],
    unique: true,
    lowercase: true,
    validate: {
      validator: (email: string) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email),
      message: '無效的電子郵件格式'
    }
  },
  password: {
    type: String,
    required: [true, '密碼是必需的'],
    minlength: [8, '密碼至少需要8個字符'],
    select: false
  },
  role: {
    type: String,
    enum: ['user', 'admin', 'moderator'],
    default: 'user'
  },
  profile: {
    avatar: String,
    bio: {
      type: String,
      maxlength: [500, '個人簡介不能超過500個字符']
    },
    socialLinks: {
      type: Map,
      of: String
    }
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// 索引
userSchema.index({ email: 1 });
userSchema.index({ createdAt: -1 });

export const User = model<IUser>('User', userSchema);
```

### PostgreSQL 與 Prisma 整合

```
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String
  role      Role     @default(USER)
  posts     Post[]
  profile   Profile?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  avatar String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("profiles")
}

model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("posts")
}

enum Role {
  USER
  ADMIN
  MODERATOR
}
```

```tsx
// services/prisma.service.ts
import { PrismaClient, Prisma } from '@prisma/client';

export class DatabaseService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient({
      log: process.env.NODE_ENV === 'development' ? ['query', 'info', 'warn', 'error'] : ['error'],
      errorFormat: 'pretty',
    });
  }

  async connect(): Promise<void> {
    await this.prisma.$connect();
    console.log('Prisma 連接成功');
  }

  async disconnect(): Promise<void> {
    await this.prisma.$disconnect();
  }

  get client(): PrismaClient {
    return this.prisma;
  }

  async transaction<T>(fn: (prisma: PrismaClient) => Promise<T>): Promise<T> {
    return await this.prisma.$transaction(fn);
  }
}
```

## 5. 身份驗證和授權

### JWT 身份驗證實作

```tsx
// services/auth.service.ts
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { User, JWTPayload } from '../types/auth.types';

export class AuthService {
  async generateTokens(user: User): Promise<{ accessToken: string; refreshToken: string }> {
    const payload: Omit<JWTPayload, 'iat' | 'exp'> = {
      sub: user.id,
      email: user.email,
      role: user.role
    };

    const accessToken = jwt.sign(payload, process.env.JWT_SECRET!, {
      expiresIn: '15m',
      algorithm: 'HS256'
    });

    const refreshToken = jwt.sign(payload, process.env.JWT_REFRESH_SECRET!, {
      expiresIn: '7d',
      algorithm: 'HS256'
    });

    return { accessToken, refreshToken };
  }

  async hashPassword(password: string): Promise<string> {
    const saltRounds = 12;
    return bcrypt.hash(password, saltRounds);
  }

  async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }
}

// middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { JWTPayload, User } from '../types/auth.types';
import { AppError } from '../utils/errors';

export interface AuthenticatedRequest extends Request {
  user?: User;
}

export const authenticateToken = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    const token = authHeader?.split(' ')[1];

    if (!token) {
      throw new AppError('Access token required', 401);
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as JWTPayload;

// 從資料庫獲取用戶資訊
    const user = await getUserById(decoded.sub);
    if (!user) {
      throw new AppError('User not found', 401);
    }

    req.user = user;
    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new AppError('Invalid token', 401));
    } else {
      next(error);
    }
  }
};
```

### 基於角色的存取控制 (RBAC)

```tsx
// middleware/rbac.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { UserRole } from '../types/auth.types';
import { AuthenticatedRequest } from './auth.middleware';
import { AppError } from '../utils/errors';

export const requireRole = (roles: UserRole[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    if (!req.user) {
      throw new AppError('Authentication required', 401);
    }

    if (!roles.includes(req.user.role)) {
      throw new AppError('Insufficient permissions', 403);
    }

    next();
  };
};

// 使用範例
app.get('/admin/users',
  authenticateToken,
  requireRole([UserRole.ADMIN]),
  getUsersController
);
```

## 6. 錯誤處理和日誌記錄

### 自訂錯誤類別

```tsx
// utils/errors.ts
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly timestamp: Date;

  constructor(
    message: string,
    statusCode: number = 500,
    isOperational: boolean = true
  ) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.timestamp = new Date();

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  public readonly fields: Record<string, string>;

  constructor(message: string, fields: Record<string, string>) {
    super(message, 400);
    this.fields = fields;
  }
}
```

### 全域錯誤處理中間件

```tsx
// middleware/error.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { AppError } from '../utils/errors';
import { logger } from '../utils/logger';

export const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  let err = error as AppError;

// 記錄錯誤
  logger.error('Error occurred:', {
    message: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

// 處理已知錯誤
  if (!(error instanceof AppError)) {
    err = new AppError('Internal server error', 500, false);
  }

// 開發環境顯示詳細錯誤
  if (process.env.NODE_ENV === 'development') {
    res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.message,
        stack: err.stack,
        statusCode: err.statusCode
      }
    });
  } else {
// 生產環境隱藏敏感資訊
    res.status(err.statusCode).json({
      success: false,
      error: {
        message: err.isOperational ? err.message : 'Something went wrong',
        statusCode: err.statusCode
      }
    });
  }
};
```

### 日誌記錄最佳實踐

```tsx
// utils/logger.ts (使用Winston)
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';

const logFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.errors({ stack: true }),
  winston.format.json()
);

export const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: logFormat,
  defaultMeta: {
    service: 'express-api',
    environment: process.env.NODE_ENV
  },
  transports: [
    new DailyRotateFile({
      filename: 'logs/error-%DATE%.log',
      level: 'error',
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d'
    }),
    new DailyRotateFile({
      filename: 'logs/combined-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d'
    })
  ]
});

// 開發環境添加控制台輸出
if (process.env.NODE_ENV === 'development') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}
```

## 7. 測試策略

### Jest 單元測試配置

```jsx
// package.json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "jest": {
    "testEnvironment": "node",
    "collectCoverageFrom": [
      "src/**/*.ts",
      "!src/index.ts"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```

### API 端點測試

```tsx
// tests/integration/api.test.ts
import request from 'supertest';
import app from '../../src/app';

describe('API Integration Tests', () => {
  describe('GET /api/users', () => {
    it('應該返回用戶列表', async () => {
      const response = await request(app)
        .get('/api/users')
        .expect('Content-Type', /json/)
        .expect(200);

      expect(response.body).toHaveProperty('users');
      expect(Array.isArray(response.body.users)).toBe(true);
    });
  });

  describe('POST /api/users', () => {
    it('應該創建新用戶', async () => {
      const userData = {
        name: 'John Doe',
        email: 'john@example.com'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect('Content-Type', /json/)
        .expect(201);

      expect(response.body).toHaveProperty('user');
      expect(response.body.user.name).toBe(userData.name);
    });
  });
});
```

### 測試資料庫設定

```tsx
// tests/setup/database.ts
import mongoose from 'mongoose';
import { MongoMemoryServer } from 'mongodb-memory-server';

let mongoServer: MongoMemoryServer;

beforeAll(async () => {
  mongoServer = await MongoMemoryServer.create();
  const mongoUri = mongoServer.getUri();
  await mongoose.connect(mongoUri);
});

afterAll(async () => {
  await mongoose.disconnect();
  await mongoServer.stop();
});

beforeEach(async () => {
  const collections = mongoose.connection.collections;
  for (const key in collections) {
    await collections[key].deleteMany({});
  }
});
```

## 8. 部署和生產環境配置

### Docker 容器化

```docker
# Dockerfile (生產環境)
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

FROM node:18-alpine as production

ENV NODE_ENV=production
ENV PORT=3000

# 建立非 root 用戶
RUN addgroup -g 1001 -S nodejs
RUN adduser -S express -u 1001

WORKDIR /app

# 複製依賴項
COPY --from=builder --chown=express:nodejs /app/node_modules ./node_modules
COPY --chown=express:nodejs . .

USER express

EXPOSE 3000

# 健康檢查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["node", "dist/index.js"]
```

### Docker Compose 配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DB_HOST=db
      - DB_PORT=5432
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - db
      - redis
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=myapp
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:

```

### CI/CD GitHub Actions

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run tests
      run: npm test
      env:
        NODE_ENV: test
        DB_HOST: localhost
        DB_PORT: 5432

    - name: Run coverage
      run: npm run test:coverage

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy to production
      run: echo "部署到生產環境"
```

## 9. 安全性最佳實踐

### 安全標頭配置

```tsx
// config/security.config.ts
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import cors from 'cors';

export const helmetConfig = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'"],
      connectSrc: ["'self'", "https://api.example.com"]
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
});

export const corsConfig = {
  origin: process.env.NODE_ENV === 'production'
    ? ['https://yourdomain.com']
    : ['http://localhost:3000'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allow edHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
  credentials: true
};

export const rateLimitConfig = rateLimit({
  windowMs: 15 *  60 * 1000,// 15分鐘
  max: 100,// 每IP限制100次請求
  message: {
    error: '請求太頻繁，請稍後再試'
  },
  standardHeaders: true,
  legacyHeaders: false
});

```

### 資料驗證和清理

```tsx
// middleware/validation.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { ValidationError } from '../utils/errors';

export const validateBody = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        const fields = error.errors.reduce((acc, err) => {
          acc[err.path.join('.')] = err.message;
          return acc;
        }, {} as Record<string, string>);

        next(new ValidationError('Validation failed', fields));
      } else {
        next(error);
      }
    }
  };
};

// schemas/user.schema.ts
import { z } from 'zod';

export const createUserSchema = z.object({
  username: z.string()
    .min(3, '用戶名至少需要3個字符')
    .max(30, '用戶名不能超過30個字符')
    .regex(/^[a-zA-Z0-9_]+$/, '用戶名只能包含字母、數字和下劃線'),
  email: z.string().email('無效的電子郵件格式'),
  password: z.string()
    .min(8, '密碼至少需要8個字符')
    .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
           '密碼必須包含大小寫字母、數字和特殊字符')
});

```

## 10. 效能優化

### Redis 快取機制

```tsx
// services/cache.service.ts
import Redis from 'ioredis';

class CacheService {
  private redis: Redis;

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD
    });
  }

  cache(options: { ttl?: number; keyGenerator?: (req: Request) => string } = {}) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const cacheKey = options.keyGenerator?.(req) || this.defaultKeyGenerator(req);

      const cached = await this.redis.get(cacheKey);
      if (cached) {
        const data = JSON.parse(cached);
        res.set('X-Cache', 'HIT');
        return res.status(data.statusCode).json(data.body);
      }

      const originalJson = res.json.bind(res);
      res.json = (obj: any) => {
        this.cacheResponse(cacheKey, res.statusCode, obj, options.ttl || 300);
        res.set('X-Cache', 'MISS');
        return originalJson(obj);
      };

      next();
    };
  }

  private async cacheResponse(key: string, statusCode: number, body: any, ttl: number) {
    await this.redis.setex(key, ttl, JSON.stringify({ statusCode, body }));
  }

  private defaultKeyGenerator(req: Request): string {
    return `${req.method}:${req.originalUrl}`;
  }
}

export const cacheService = new CacheService();
```

### 壓縮和靜態檔案優化

```tsx
// middleware/compression.middleware.ts
import compression from 'compression';

export const smartCompression = compression({
  level: (req, res) => {
    const isMobile = /Mobile|Android|iPhone/i.test(req.get('User-Agent') || '');
    return isMobile ? 6 : 9;
  },
  filter: (req, res) => {
    const contentType = res.get('Content-Type') || '';
    return contentType.includes('json') || contentType.startsWith('text/');
  }
});
```

## 11. 實際範例程式碼和完整專案示例

### 完整的 CRUD API 控制器

```tsx
// controllers/UserController.ts
import { Request, Response, NextFunction } from 'express';
import { UserService } from '../services/UserService';
import { AppError } from '../utils/errors';

export class UserController {
  constructor(private userService: UserService) {}

  async createUser(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const userData = req.body;
      const newUser = await this.userService.create(userData);

      res.status(201).json({
        success: true,
        data: newUser,
        message: '用戶創建成功'
      });
    } catch (error) {
      next(error);
    }
  }

  async getAllUsers(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = Math.min(parseInt(req.query.limit as string) || 10, 100);

      const result = await this.userService.findAll({ page, limit });

      res.json({
        success: true,
        data: result.users,
        pagination: {
          total: result.total,
          page,
          limit,
          hasMore: result.hasMore
        }
      });
    } catch (error) {
      next(error);
    }
  }

  async getUserById(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { id } = req.params;
      const user = await this.userService.findById(id);

      if (!user) {
        throw new AppError('用戶未找到', 404);
      }

      res.json({
        success: true,
        data: user
      });
    } catch (error) {
      next(error);
    }
  }

  async updateUser(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { id } = req.params;
      const updateData = req.body;

      const updatedUser = await this.userService.update(id, updateData);

      res.json({
        success: true,
        data: updatedUser,
        message: '用戶更新成功'
      });
    } catch (error) {
      next(error);
    }
  }

  async deleteUser(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const { id } = req.params;
      await this.userService.delete(id);

      res.status(204).send();
    } catch (error) {
      next(error);
    }
  }
}
```

### 檔案上傳處理服務

```tsx
// services/FileUploadService.ts
import multer from 'multer';
import sharp from 'sharp';
import path from 'path';
import fs from 'fs';

export class FileUploadService {
  private storage = multer.diskStorage({
    destination: (req, file, cb) => {
      const dateFolder = new Date().toISOString().split('T')[0];
      const destPath = path.join(__dirname, '../uploads', dateFolder);
      fs.mkdirSync(destPath, { recursive: true });
      cb(null, destPath);
    },
    filename: (req, file, cb) => {
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      cb(null, `${file.fieldname}-${uniqueSuffix}${path.extname(file.originalname)}`);
    }
  });

  private fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'application/pdf'];
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('無效的檔案類型'));
    }
  };

  getUploadMiddleware() {
    return multer({
      storage: this.storage,
      limits: { fileSize: 10 * 1024 * 1024 },// 10MB
      fileFilter: this.fileFilter
    });
  }

  async processImage(filePath: string): Promise<string> {
    const processedPath = filePath.replace(/(\.[^.]+)$/, '_processed$1');

    await sharp(filePath)
      .resize(1200, 1200, { fit: 'inside', withoutEnlargement: true })
      .jpeg({ quality: 85, progressive: true })
      .toFile(processedPath);

    return processedPath;
  }
}
```

### 完整的應用程式配置

```tsx
// app.ts
import express from 'express';
import cors from 'cors';
import { helmetConfig, corsConfig, rateLimitConfig } from './config/security.config';
import { errorHandler } from './middleware/error.middleware';
import { logger } from './utils/logger';
import { requestId, responseTime } from './middleware/custom';
import { smartCompression } from './middleware/compression.middleware';
import userRoutes from './routes/userRoutes';
import authRoutes from './routes/authRoutes';

class App {
  public app: express.Application;

  constructor() {
    this.app = express();
    this.initializeMiddleware();
    this.initializeRoutes();
    this.initializeErrorHandling();
  }

  private initializeMiddleware(): void {
// 信任代理（用於生產環境）
    if (process.env.NODE_ENV === 'production') {
      this.app.set('trust proxy', 1);
    }

// 安全中間件
    this.app.use(helmetConfig);
    this.app.use(cors(corsConfig));
    this.app.use(rateLimitConfig);
    this.app.use(smartCompression);

// 請求解析和處理
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// 自訂中間件
    this.app.use(requestId);
    this.app.use(responseTime);

// 請求日誌
    this.app.use((req, res, next) => {
      logger.info('Incoming request', {
        method: req.method,
        url: req.url,
        ip: req.ip,
        userAgent: req.get('User-Agent')
      });
      next();
    });
  }

  private initializeRoutes(): void {
// 健康檢查
    this.app.get('/health', (req, res) => {
      res.status(200).json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
      });
    });

// API 路由
    this.app.use('/api/v1/auth', authRoutes);
    this.app.use('/api/v1/users', userRoutes);
  }

  private initializeErrorHandling(): void {
// 404 處理
    this.app.use((req, res) => {
      res.status(404).json({
        success: false,
        message: `找不到路由 ${req.originalUrl}`
      });
    });

// 全域錯誤處理
    this.app.use(errorHandler);
  }
}

export default new App().app;
```

### 伺服器啟動檔案

```tsx
// index.ts
import app from './app';
import { connectMongoDB } from './config/database';
import { logger } from './utils/logger';

const PORT = process.env.PORT || 3000;

async function startServer() {
  try {
// 連接資料庫
    await connectMongoDB();

// 啟動伺服器
    const server = app.listen(PORT, () => {
      logger.info(`🚀 Server is running on port ${PORT}`);
      logger.info(`📡 Environment: ${process.env.NODE_ENV}`);
      logger.info(`🔗 Local: http://localhost:${PORT}`);
    });

// 優雅關閉處理
    const gracefulShutdown = (signal: string) => {
      logger.info(`${signal} received`);
      server.close(() => {
        logger.info('Server closed');
        process.exit(0);
      });
    };

    process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
    process.on('SIGINT', () => gracefulShutdown('SIGINT'));

  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

startServer();
```

## 總結

這份完整的 Express.js TypeScript 手冊涵蓋了現代 Web 開發的所有重要面向：

### 關鍵特色

- **2025年最新技術**：Express 5.0、TypeScript 5.x、最新安全實踐
- **完整程式碼範例**：可直接使用的實際代碼
- **生產環境就緒**：包含部署、監控、優化策略
- **安全優先**：遵循 OWASP 安全標準
- **效能優化**：快取、壓縮、資料庫優化
- **測試導向**：完整的測試策略和範例

### 開發工作流程

1. **設定開發環境**：TypeScript + Express + 開發工具
2. **建立基礎架構**：路由、中間件、資料庫
3. **實作業務邏輯**：控制器、服務層、驗證
4. **新增安全性**：認證、授權、資料驗證
5. **效能優化**：快取、壓縮、監控
6. **測試和部署**：單元測試、CI/CD、容器化

### 最佳實踐要點

- 使用 TypeScript 獲得類型安全
- 實作適當的錯誤處理和日誌記錄
- 遵循 RESTful API 設計原則
- 實施強大的安全措施
- 進行充分的測試覆蓋
- 優化應用程式效能
- 使用現代化部署策略

這份手冊將協助您建構高品質、可維護、安全的 Express.js TypeScript 應用程式，滿足現代 Web 開發的各種需求。